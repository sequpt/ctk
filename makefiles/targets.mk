################################################################################
# TARGETS
################################################################################
ifneq ($(PROJECT_TYPE),$(findstring $(PROJECT_TYPE),program shared static))
    $(error PROJECT_TYPE must be one of [program, shared, static])
endif

.PHONY: all
all:: $(PROJECT_DEPS) $(PROJECT_TYPE)

# Compile *.c files
$(OBJ_PATH)/%.o: %.c $(OBJ_DEPS)
	$(COMPILE)

# Analyze code with various tools
.PHONY: analyze
analyze:: | $(SCANBUILD_PATH) $(CPPCHECK_PATH)
	$(SCANBUILD)
	$(CPPCHECK)

# Remove existing build files
.PHONY: clean
clean::
	rm -rf $(BUILD_PATH)
	rm -rf $(DEP_PATH)
	rm -rf $(OBJ_PATH)

# Code coverage tools
.PHONY: cov
cov:: $(INFO_FILES) | $(GCOV_PATH)
	$(GCOV)
	$(LCOV_FINAL)
	$(GENHTML)
	mv ./*.gcov ./coverage/gcov

$(LCOV_PATH)/%.info: $(OBJECT_PATH)/%.o | $(LCOV_PATH)
	$(LCOV)

# Generate documentation
.PHONY: doc
doc:: | $(DOXYGEN_PATH)
	$(DOXYGEN)

# Install header and library files
.PHONY: install
install:: install_header install_lib

# Install header files
.PHONY: install_header
install_header:: all | $(HEADER_INSTALL_PATH)
	cp -r $(INC_PATH)/. $(HEADER_INSTALL_PATH)

# Install library files
.PHONY: install_lib
install_lib:: all | $(LIB_INSTALL_PATH)
	cp -ar $(BUILD_PATH)/* $(LIB_INSTALL_PATH)
	find $(EXTERNAL_LIB_PATH) -type f,l -exec cp -at $(LIB_INSTALL_PATH) {} +

ifeq ($(PROJECT_TYPE),program)
# Build program
.PHONY: program
program:: $(PROGRAM_PATH)

$(PROGRAM_PATH): $(OBJ_FILES) | $(BUILD_PATH)
	$(LINK_PROGRAM)
endif

# Remove existing build files and build again
.PHONY: rebuild
rebuild:: clean all

ifeq ($(PROJECT_TYPE),program)
# Build project if not already build and run it
.PHONY: run
run:: all $(RUN_DEPS)
endif

ifeq ($(PROJECT_TYPE),$(findstring $(PROJECT_TYPE),shared static))
# Build a shared library
.PHONY: shared
shared:: $(LIB_SHARED_XYZ_PATH)

$(LIB_SHARED_XYZ_PATH): $(OBJ_FILES) | $(BUILD_PATH)
	$(LINK_SHARED)
	ln -sf $(LIB_SHARED_XYZ) $(LIB_SHARED_X_PATH)
	ln -sf $(LIB_SHARED_X) $(LIB_SHARED_PATH)

# Build a static library
.PHONY: static
static:: $(LIB_STATIC_PATH)

$(LIB_STATIC_PATH): $(OBJ_FILES) | $(BUILD_PATH)
	$(ARCHIVE)
endif

# Tests
.PHONY: test
test:: all
	$(MAKE) -C $(TEST_PATH) run BUILD_MODE=$(BUILD_MODE)

# Uninstall everything
.PHONY: uninstall
uninstall::
	rm -rf $(HEADER_INSTALL_PATH)
	rm -rf $(LIB_INSTALL_PATH)

# Targets to create output directories
# mkdir -p: No error if directory exists and make parent directories as needed
$(ANALYSIS_PATH):       ;mkdir -p $(ANALYSIS_PATH)
$(BUILD_PATH):          ;mkdir -p $(BUILD_PATH)
$(CPPCHECK_PATH):       ;mkdir -p $(CPPCHECK_PATH)
$(DEP_PATH):            ;mkdir -p $(DEP_PATH)
$(DOXYGEN_PATH):        ;mkdir -p $(DOXYGEN_PATH)
$(GCOV_PATH):           ;mkdir -p $(GCOV_PATH)
$(HEADER_INSTALL_PATH): ;mkdir -p $(HEADER_INSTALL_PATH)
$(LIB_INSTALL_PATH):    ;mkdir -p $(LIB_INSTALL_PATH)
$(LCOV_PATH):           ;mkdir -p $(LCOV_PATH)
$(OBJ_PATH):            ;mkdir -p $(OBJ_PATH)
$(SCANBUILD_PATH):      ;mkdir -p $(SCANBUILD_PATH)
$(VALGRIND_PATH):       ;mkdir -p $(VALGRIND_PATH)
# Make each *.d file a target so make won't fail if the file doesn't exist
$(DEP_FILES):
# Only include *.d files if target is not 'clean', 'doc' or 'uninstall'
ifneq ($(MAKECMDGOALS),$(findstring $(PROJECT_TYPE),clean doc uninstall))
    include $(wildcard $(DEP_FILES))
endif
# Delete files generated by a target which failed(prevent corrupted files)
.DELETE_ON_ERROR:
